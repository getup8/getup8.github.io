<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GetUp8</title>
    <link>http://www.getup8.com/</link>
    <description>Recent content on GetUp8</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Oct 2016 23:40:37 -0400</lastBuildDate>
    <atom:link href="http://www.getup8.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Power of One (and Zero)</title>
      <link>http://www.getup8.com/post/power_of_one_and_zero/</link>
      <pubDate>Wed, 19 Oct 2016 23:40:37 -0400</pubDate>
      
      <guid>http://www.getup8.com/post/power_of_one_and_zero/</guid>
      <description>

&lt;p&gt;About two years ago, my girlfriend and I were looking for a little extra
motivation to get us in the gym or out running more often.  We both somewhat
regularly worked out but it was often a slog and we&amp;rsquo;d go through peaks and
valleys of activity.&lt;/p&gt;

&lt;p&gt;So we decided to set up a simple spreadsheet in the cloud and track our
progress.  Initially I was thinking of trying to keep track of what specific
exercises we did, how many sets, reps, etc. but it was difficult to set up a
spreadsheet to track all the possible exercises we would do.  Also, there were
some days we didn&amp;rsquo;t feel like pushing ourselves too hard so constantly feeling
pressured to beat our previous efforts seemed stressful.&lt;/p&gt;

&lt;p&gt;In the end, the spreadsheet just looked like this:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Alex &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Lauren &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2016-09-23&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Ran 5mi!&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Ran 5mi w/ A!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2016-09-24&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;:(&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Pilates&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2016-09-25&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Gym, upper body&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;:(&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The days&amp;rsquo;s date, a binary column for whether we worked our or not, and then
an optional note to say what you did.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;500 days later&lt;/strong&gt;, we&amp;rsquo;re still going strong.  We&amp;rsquo;ve filled out every single
day. Not always on the same day, I admit, sometimes we&amp;rsquo;ll go a few days or more
without marking a zero or a one but inevitably we&amp;rsquo;ll remember and backfill the
unmarked days.&lt;/p&gt;

&lt;h2 id=&#34;why-this-works&#34;&gt;Why This Works&lt;/h2&gt;

&lt;p&gt;I think there are a few reasons we&amp;rsquo;ve been able to keep this up for so long.&lt;/p&gt;

&lt;h3 id=&#34;simplicity&#34;&gt;Simplicity&lt;/h3&gt;

&lt;p&gt;The simplicity of tracking makes it near painless.  All you need to do is mark
a zero or one.  We even started allowing for the occassional 0.5 if you had
an in-betweener (a very long walk let&amp;rsquo;s say).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy to do on a daily basis but I think more importantly, it&amp;rsquo;s easy to
catch up on if you fall behind.  Simple and straightforward is key.&lt;/p&gt;

&lt;h3 id=&#34;visibility-accessibility&#34;&gt;Visibility / Accessibility&lt;/h3&gt;

&lt;p&gt;Since we did it in Google Spreadsheets, it was almost always accessible.  We
also would just leave it open in a Chrome tab (you could even pin it) so every
time you were on the computer, you couldn&amp;rsquo;t help but noticing it.&lt;/p&gt;

&lt;p&gt;No alarms, no automated reminders; it was just often visible and easily
accessible.&lt;/p&gt;

&lt;h3 id=&#34;a-little-competition-accountability&#34;&gt;A Little Competition / Accountability&lt;/h3&gt;

&lt;p&gt;We were our own reminder system.  When one of us was falling off the wagon, the
other would gently nudge the other, sometimes as passively as just leaving a
tagged comment in the sheet.&lt;/p&gt;

&lt;p&gt;Once you start, and especially once you&amp;rsquo;ve kept it up for some weeks, you don&amp;rsquo;t
NOT want to fill it out.  And I think it&amp;rsquo;s just the right amount of guilt you
feel when you have to mark that zero.  The second zero is a little tougher.
The third in a row and you have all the motivation you need to strap on those
running shoes.&lt;/p&gt;

&lt;p&gt;But really, doing it together is what makes it fun.  You want to challenge
each other and you also don&amp;rsquo;t want to let the other down.  So you keep going
and make it part of your every day habits.&lt;/p&gt;

&lt;h3 id=&#34;no-major-life-changes&#34;&gt;No Major Life Changes&lt;/h3&gt;

&lt;p&gt;Lastly, I think it&amp;rsquo;s been possible for us to keep this going for so long
because we haven&amp;rsquo;t had any big life upsets.  No big moves, no babies, no
tragedies and we&amp;rsquo;ve been healthy (which I&amp;rsquo;m very grateful for).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;If you&amp;rsquo;re looking to make a change, to pick up a new skill, or just want to
support an activity you&amp;rsquo;re already doing, consider starting a similar system.
It&amp;rsquo;s fun, it&amp;rsquo;s easy and if you&amp;rsquo;re a nerd, you even get the benefit of having
some cool data to play with after you&amp;rsquo;ve done it awhile (post on that coming
soon).  Let me know how it goes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 12: Trees, Continued</title>
      <link>http://www.getup8.com/classes/data-structures/lecture12/</link>
      <pubDate>Mon, 17 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture12/</guid>
      <description>

&lt;p&gt;Material covered through next lecture (on Wednesday) will be on Midterm.&lt;/p&gt;

&lt;p&gt;This week&amp;rsquo;s resitation sessions will be midterm review.&lt;/p&gt;

&lt;p&gt;Next Monday will be Midterm review.  Do not miss this.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;binarysearchtree-class&#34;&gt;BinarySearchTree Class&lt;/h2&gt;

&lt;p&gt;Look up and understand this code, it&amp;rsquo;s provided in the book PDF.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Comparable&amp;lt;? super AnyType&amp;gt;&lt;/code&gt;says it has to be comparable to itself or any
superclass of itself.&lt;/p&gt;

&lt;p&gt;He says it&amp;rsquo;s gratuitous having two Constructors since when you insert, you
replace the null reference with a single leaf node.&lt;/p&gt;

&lt;h3 id=&#34;public-boolean-contains-anytype-x-method&#34;&gt;&lt;code&gt;public boolean contains(AnyType x)&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;Returns &lt;code&gt;contains(x, root)&lt;/code&gt;.  The true &lt;code&gt;contains&lt;/code&gt; method has to take in the
root.  This one does not and is not recursive, it actually calls the &lt;code&gt;private&lt;/code&gt;
recursive method with &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We see this &lt;code&gt;public&lt;/code&gt; / &lt;code&gt;private&lt;/code&gt; pairing a lot in this.&lt;/p&gt;

&lt;h3 id=&#34;insert-method&#34;&gt;Insert Method&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;public boolean contains(AnyType x)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The method takes in a node we want to insert.  If it&amp;rsquo;s already in the tree,
we don&amp;rsquo;t do anything.  If it&amp;rsquo;s not, we add it in, and make sure the rules of
the tree are upheld.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void insert(AnyType x) {
    // We assign to root here just in case the tree is empty.
    // So the recursive `insert` that this calls returns the &amp;quot;new&amp;quot;
    // root of the tree
    root = insert(x, root);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;private&lt;/code&gt; method is recursive and similar to &lt;code&gt;contains&lt;/code&gt; in its logic.&lt;/p&gt;

&lt;h3 id=&#34;find-min-and-find-max&#34;&gt;Find Min and Find Max&lt;/h3&gt;

&lt;p&gt;We basically just search left (right) until we find a left &lt;code&gt;null&lt;/code&gt; reference and
return that node with the &lt;code&gt;null&lt;/code&gt; pointer.&lt;/p&gt;

&lt;p&gt;These are tail recursions; when you make a recursive call as the very last line
of your method.  You&amp;rsquo;re effectively iterating across the dataset.  These can
very easily be replace with &lt;code&gt;while&lt;/code&gt; loops.&lt;/p&gt;

&lt;p&gt;In the text, &lt;code&gt;findMax&lt;/code&gt; is written iteratively as a while loop instead of as a
recursion.&lt;/p&gt;

&lt;h3 id=&#34;height-method&#34;&gt;Height Method&lt;/h3&gt;

&lt;p&gt;Find the longer of the left and right subtrees (recursively) and add one (the
root).&lt;/p&gt;

&lt;h3 id=&#34;print-tree&#34;&gt;Print Tree&lt;/h3&gt;

&lt;p&gt;Standard in-order traversal. Will print the data in sorted order.&lt;/p&gt;

&lt;h3 id=&#34;remove&#34;&gt;Remove&lt;/h3&gt;

&lt;p&gt;Leaf nodes are simple.  Just drop them.&lt;/p&gt;

&lt;p&gt;What if we delete the root?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Replace with the smallest thing on the right hand side.&lt;/li&gt;
&lt;li&gt;Or the largest thing on the left hand side.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the steps are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find the largest on the left side using &lt;code&gt;findMax&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace root with it&lt;/li&gt;
&lt;li&gt;Recursively remove it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;public&lt;/code&gt; method very similar to &lt;code&gt;insert&lt;/code&gt; method.&lt;br /&gt;
&lt;code&gt;private&lt;/code&gt; method starts out with base case similar to others (null tree).&lt;/p&gt;

&lt;p&gt;Pretty simple if the node just has a single child.  If it has two, it&amp;rsquo;s kinda
hard.&lt;/p&gt;

&lt;p&gt;Look over the code and understand this.  Fading in class fast.&lt;/p&gt;

&lt;h3 id=&#34;lazy-deletion&#34;&gt;Lazy Deletion&lt;/h3&gt;

&lt;p&gt;Add a field to the TreeNode class &lt;code&gt;valid&lt;/code&gt;.  If it&amp;rsquo;s &lt;code&gt;true&lt;/code&gt;, the node is marked
to exist.  If it&amp;rsquo;s &lt;code&gt;false&lt;/code&gt;, the node is marked to not exist.  So in lazy
deletion, you just do a &lt;code&gt;contains&lt;/code&gt; check and if it finds it, you just flip
the value to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All the other methods need to be adjusted to take account of this though and
check whether nodes are &lt;code&gt;valid&lt;/code&gt; or not.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;findMax&lt;/code&gt; and &lt;code&gt;findMin&lt;/code&gt; actually become quite tough.&lt;/p&gt;

&lt;h2 id=&#34;avl-trees&#34;&gt;AVL Trees&lt;/h2&gt;

&lt;p&gt;Binary search trees with an added condition: the height of the left subtree
cannot differ from the height of the right subtree by more than one.  If at
any time, an insertion or deletion is made that disrupts this balance, you need
to perform a single or double rotation to fix it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 11: Trees, Continued</title>
      <link>http://www.getup8.com/classes/data-structures/lecture11/</link>
      <pubDate>Wed, 12 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture11/</guid>
      <description>

&lt;p&gt;Root node is usually operator.&lt;/p&gt;

&lt;h3 id=&#34;post-order-traversal&#34;&gt;Post-Order Traversal&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Gives us Postfix expressions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;in-order-traversal&#34;&gt;In-Order Traversal&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Do the left&lt;/li&gt;
&lt;li&gt;Print out the result&lt;/li&gt;
&lt;li&gt;Do the right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using a tree to evaluate expressions.&lt;/p&gt;

&lt;p&gt;What should we store the operators and operands as?  And how do we tell them
apart?&lt;/p&gt;

&lt;p&gt;Some rules (I think):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A leaf has to be an operand&lt;/li&gt;
&lt;li&gt;An inner node has to be an operator&lt;/li&gt;
&lt;li&gt;Another?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementing-a-tree-for-expressions-expression-trees&#34;&gt;Implementing a Tree for Expressions: Expression Trees&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ExprNode {
    char operator;
    int operand;
    ExprNode left;
    ExprNode right;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also do a string and then try to parse it and see if it&amp;rsquo;s a number or
not.  Need to be careful of negative numbers.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re making the decision to just have two instance vars, one of each type.
Then we can have logic to determine which value to look at (and where to store
a value as well).&lt;/p&gt;

&lt;p&gt;Programming problem #1 on Homework 3.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Construct tree&lt;/li&gt;
&lt;li&gt;Postfix expr&lt;/li&gt;
&lt;li&gt;Prefix expr&lt;/li&gt;
&lt;li&gt;Infix expr&lt;/li&gt;
&lt;li&gt;Evaluate the tree&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void postFix(ExprNode t) {
    // Print out the left, then the right, then the node itself.

    // base case. tree is empty.
    if (t == null) {
        return;
    }
    postFix(t.left);  // If these are leafs, it will be our base case and just return
    postFix(t.right);

    // Now we want to print out. Need to determine if it&#39;s a operator or
    // an operand.
    if (t.left != null) {
        System.out.println(t.operator);
    } else {
        System.outprintln(t.operand);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if we want to change this to prefix?  Basically just move the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;
statements to before the recursive call.&lt;/p&gt;

&lt;p&gt;What about the infix?  You can&amp;rsquo;t just put the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; in the middle of the
left and right postFix calls.  Order of operations is important!&lt;/p&gt;

&lt;p&gt;Print parentheses pre and post the &lt;code&gt;postFix(t.left)&lt;/code&gt; call.&lt;/p&gt;

&lt;h3 id=&#34;how-do-we-evaluate-the-tree&#34;&gt;How do we evaluate the tree?&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Evaluate the left side&lt;/li&gt;
&lt;li&gt;Evaluate the right side&lt;/li&gt;
&lt;li&gt;Do the expression&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So evaluating a tree is actually just a flavor of postfix.&lt;/p&gt;

&lt;h2 id=&#34;creating-expression-trees&#34;&gt;Creating Expression Trees&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Input:&lt;/strong&gt; postfix expression from a user&lt;br /&gt;
&lt;strong&gt;Output:&lt;/strong&gt; an expression tree object&lt;/p&gt;

&lt;p&gt;We use stacks of nodes!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;3 4 * 5 +&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;encase 3 into a node and &lt;code&gt;push&lt;/code&gt; to stack&lt;/li&gt;
&lt;li&gt;encase 4 into a node and &lt;code&gt;push&lt;/code&gt; to stack&lt;/li&gt;
&lt;li&gt;oooh we&amp;rsquo;ve come to an operator; create a node around the operator and then
&lt;code&gt;pop&lt;/code&gt; the stack twice.

&lt;ul&gt;
&lt;li&gt;First &lt;code&gt;pop&lt;/code&gt; goes to the right reference&lt;/li&gt;
&lt;li&gt;Second &lt;code&gt;pop&lt;/code&gt; goes to the left reference&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Now push the root of the tree we just created back onto the stack (root
of the tree is the &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; hanging off of it as children)&lt;/li&gt;
&lt;li&gt;5 because a node (&lt;code&gt;ExprNode&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;+&lt;/code&gt;, encase it, &lt;code&gt;pop&lt;/code&gt; the stack twice again.

&lt;ul&gt;
&lt;li&gt;5 goes to the right&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExprNode&lt;/code&gt; (with &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; with it) on the left&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt; back to the stack&lt;/li&gt;
&lt;li&gt;End of expression! Soo&amp;hellip;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; the stack! And get a reference to the root &lt;code&gt;ExprNode&lt;/code&gt; of the tree&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;code&#34;&gt;Code.&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s a distinction between the &lt;code&gt;ExprTree&lt;/code&gt; class and the &lt;code&gt;ExprNode&lt;/code&gt; class.
The job of the &lt;code&gt;ExprTree&lt;/code&gt; is to encapsulate &lt;code&gt;ExprNode&lt;/code&gt;.  The instance variable
will be the root of the tree.&lt;/p&gt;

&lt;p&gt;Constructor for &lt;code&gt;ExprTree&lt;/code&gt; class would take in a postfix expression and build
up the tree.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ExprTree.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ExprTree {

    private ExprNode root;

    public ExprTree(String postFix) {
        // run through stack-based algorithm to build the expression tree
        // remember, you&#39;re pushing `ExprNode`s
        // When done, pop the stack and make that the root.
    }

    // Evaluate the expression tree.  Public version of the function since the
    // user doesn&#39;t know anything about the root node.
    public eval() {
        return eval(root);
    }

    private int eval(ExprNode t) {
        // do your traversal to evaluate the tree rooted at t and return it
    }

    static private class ExprNode {
        int operand;
        char operator;
        ExprNode left;
        ExprNode right;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;binary-search-tree&#34;&gt;Binary Search Tree&lt;/h2&gt;

&lt;h3 id=&#34;rules&#34;&gt;Rules&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Every single node in the left subtree must be smaller than the root node&lt;/li&gt;
&lt;li&gt;Every single node in the right subtree must be larger than the root node&lt;/li&gt;
&lt;li&gt;This must be true at every node&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A perfect binary search tree has perfect balance.&lt;/p&gt;

&lt;p&gt;At each node, ask if smaller or larger, move to left or right accordingly and
keep going (recursion).  Keep going until you find the value or you reach a
&lt;code&gt;null&lt;/code&gt; link.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re making the assumption that there are no repeat values.&lt;/p&gt;

&lt;p&gt;So what methods should we have for the ADT for a Binary Search Tree?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt;: just like &lt;code&gt;contains&lt;/code&gt;, go through looking for it, if you find it,
 just return; if you don&amp;rsquo;t, replace your value with a &lt;code&gt;null&lt;/code&gt; link.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PBST means height is about &lt;code&gt;O(log N)&lt;/code&gt; so both &lt;code&gt;contains&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; run that
fast.  But not for non-perfect BSTs.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;5, 4, 3, 2, 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Basically you end up building a &lt;code&gt;LinkedList&lt;/code&gt; so searching could actually be
&lt;code&gt;O(N)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If tree is very well balanced, then it&amp;rsquo;s &lt;code&gt;O(log N)&lt;/code&gt;, but if it&amp;rsquo;s not, then it&amp;rsquo;s
&lt;code&gt;O(N)&lt;/code&gt;.  Basically, you have to assume &lt;code&gt;O(N)&lt;/code&gt; is the worst case unless you
KNOW its well balanced.&lt;/p&gt;

&lt;p&gt;But there are such things as self-balancing trees, e.g. ABL trees.  For these
we can guarantee &lt;code&gt;O(log N)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finding &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is pretty easy, just keep going left or right,
respectively.  Same order as searching.&lt;/p&gt;

&lt;p&gt;Btw, an in-order traversal of a BST will give us a &lt;strong&gt;sorted list&lt;/strong&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 10: Trees</title>
      <link>http://www.getup8.com/classes/data-structures/lecture10/</link>
      <pubDate>Mon, 10 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture10/</guid>
      <description>

&lt;p&gt;Starting this lecture at 6:40 btw. 30 minutes of nothingness before.&lt;/p&gt;

&lt;h2 id=&#34;trees&#34;&gt;Trees&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Trees are a bunch of nodes&lt;/li&gt;
&lt;li&gt;Need to have references to child nodes&lt;/li&gt;
&lt;li&gt;Very likely going to iterate across children, not necessarily jump to a
specific one.&lt;/li&gt;
&lt;li&gt;You could do this with a LinkedList but there&amp;rsquo;s an easier way&lt;/li&gt;
&lt;li&gt;To iterate through children, go to &lt;code&gt;firstChild&lt;/code&gt; and then iterate through
using &lt;code&gt;nextSibling&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TreeNode&amp;lt;T&amp;gt; {
    T data;
    TreeNode&amp;lt;T&amp;gt; nextSibling;  // Similar to LinkedList
    TreeNode&amp;lt;T&amp;gt; firstChild;  // Another LinkedList type structure to children
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pre-order traversal: evaluate the node first, then evaluate the children.
Post-order: evaluate the children first, then the node.&lt;/p&gt;

&lt;h2 id=&#34;tree-traversal&#34;&gt;Tree Traversal&lt;/h2&gt;

&lt;p&gt;A pre-order tree traversal via &lt;code&gt;listAll&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Pseudo code
private void listAll(int depth) {
    printName(depth);  // Print name of object
    if(isDirectory()) {
        for each file c in this directory (for each child) {
            c.listAll(depth + 1);
        }
    }
}

public void listAll() {
    listAll(0);  // Initial call for root node calls actual recursive method
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tree-types&#34;&gt;Tree Types&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Full Binary Tree

&lt;ul&gt;
&lt;li&gt;?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Complete Binary Tree

&lt;ul&gt;
&lt;li&gt;Last row is filled up from left to right but not all the way&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Perfect Binary Tree

&lt;ul&gt;
&lt;li&gt;A complete binary tree with the last row all filled up&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Need to think about the number of nodes in a tree given the height..&lt;/p&gt;

&lt;p&gt;A perfect binary tree has &lt;code&gt;2^(h + 1) - 1&lt;/code&gt; nodes.&lt;/p&gt;

&lt;p&gt;Btw, know what &amp;ldquo;proof by induction&amp;rdquo; means.&lt;/p&gt;

&lt;h3 id=&#34;proof-by-induction&#34;&gt;Proof by Induction&lt;/h3&gt;

&lt;h4 id=&#34;base-case&#34;&gt;Base Case&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;2^(0 + 1) - 1 = 1&lt;/li&gt;
&lt;li&gt;2^(1 + 1) - 1 = 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Assume for perfect trees of height &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;k&lt;/code&gt; this holds.&lt;/p&gt;

&lt;p&gt;So now we need to prove that this works for a tree of height &lt;code&gt;k + 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A tree of height &lt;code&gt;k&lt;/code&gt; will have &lt;code&gt;2^(k + 1) - 1&lt;/code&gt; nodes.&lt;/p&gt;

&lt;p&gt;Now copy that tree and we have two identical trees.&lt;/p&gt;

&lt;p&gt;Now add a root node and point to the root nodes of those two initial trees.&lt;/p&gt;

&lt;p&gt;So now we just need to add up the nodes.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2 * (2^(k + 1) - 1) + 1&lt;/code&gt;
&lt;code&gt;2^((k + 1) + 1) - 2 + 1&lt;/code&gt;
&lt;code&gt;2^((k + 1) + 1) - 1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;question-one-on-the-midterm-will-essentially-be-this-but-on-another&#34;&gt;QUESTION ONE ON THE MIDTERM WILL ESSENTIALLY BE THIS BUT ON ANOTHER&lt;/h2&gt;

&lt;p&gt;CHARACTERISTIC OF THE BINARY TREE&lt;/p&gt;

&lt;h2 id=&#34;expression-tree&#34;&gt;Expression Tree&lt;/h2&gt;

&lt;p&gt;Tree will be represented by a full binary tree.  In a binary tree, there is
something on the &amp;ldquo;left&amp;rdquo; and something on the &amp;ldquo;right&amp;rdquo; so there is some implicit
order.&lt;/p&gt;

&lt;p&gt;Operators are interior nodes.  Operands are leaf nodes.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;3 + (2 * 5)&lt;/p&gt;

&lt;p&gt;+
3   *
  2   5&lt;/p&gt;

&lt;p&gt;Does the root node of an expression tree have to be an operand?  Nope.&lt;/p&gt;

&lt;p&gt;Interior nodes must be operators.&lt;/p&gt;

&lt;p&gt;Leaf nodes must be operands?&lt;/p&gt;

&lt;p&gt;Look at the ExpressionNode class&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ExprNode {
    Op data;  // either operator or operand
    ExprNode left;
    ExprNode right;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 9: Stacks, Queues, Trees</title>
      <link>http://www.getup8.com/classes/data-structures/lecture9/</link>
      <pubDate>Wed, 05 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture9/</guid>
      <description>

&lt;h2 id=&#34;stacks-and-postfix-infix-expression-continued&#34;&gt;Stacks and Postfix / Infix Expression (continued)&lt;/h2&gt;

&lt;p&gt;Postfix and Infix expressions.&lt;/p&gt;

&lt;p&gt;If we have an infix expression, we scan through each token and when we
encounter an operator, we don&amp;rsquo;t have all of the operands.  So we &lt;code&gt;push&lt;/code&gt; that
operator onto the stack (as long as it&amp;rsquo;s empty).  If it&amp;rsquo;s not empty and there
are other operators, we need to figure out order of operations.&lt;/p&gt;

&lt;p&gt;So we look at the top of the stack and check if it has a lower precedence of
the one we&amp;rsquo;re processing, we &lt;code&gt;push&lt;/code&gt; on to the stack.  If it&amp;rsquo;s higher, we &lt;code&gt;pop&lt;/code&gt;
it off and do the operation and keep checking until the stack is empty or we
find an operator of lower precedence.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a * b - c + d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a&lt;/li&gt;
&lt;li&gt;stack = [*]&lt;/li&gt;
&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;stack = [-, *]&lt;/li&gt;
&lt;li&gt;c&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(-)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stack = [+, *]&lt;/li&gt;
&lt;li&gt;&amp;lt;run out of tokens]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;a b * c - d +&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What about parentheses?  You &lt;code&gt;push&lt;/code&gt; open parentheses onto the stack.
Eventually you reach the end of the parentheses; when you do, you keep &lt;code&gt;pop&lt;/code&gt;ing
the stack until you get the open parentheses.  Then you &lt;code&gt;pop&lt;/code&gt; it out and get
rid of both parentheses and keep going.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a + b * c + (d * e + f) * g&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a&lt;/li&gt;
&lt;li&gt;[+]&lt;/li&gt;
&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;[*, +]&lt;/li&gt;
&lt;li&gt;c&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[+]&lt;/li&gt;
&lt;li&gt;[(, +]&lt;/li&gt;
&lt;li&gt;d&lt;/li&gt;
&lt;li&gt;[*, (, +]&lt;/li&gt;
&lt;li&gt;e&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[+, (, +]&lt;/li&gt;
&lt;li&gt;f&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;g&lt;/li&gt;
&lt;li&gt;[*, +]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;a b c * + d e * f + g * +&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Stacks are used in programs (all programs?) and are very present in how
recursion works.  Each level of the recursion pushes the step onto the stack
until we return and we start popping them all off.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;queues-and-the-josephus-game&#34;&gt;Queues and the Josephus Game&lt;/h2&gt;

&lt;p&gt;You have &lt;code&gt;n&lt;/code&gt; items in a circle, in a specific order.&lt;/p&gt;

&lt;p&gt;Then you have a second value &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You count from the first to the &lt;code&gt;k&lt;/code&gt;th person.  That person is then out.  Then
you count the next &lt;code&gt;k&lt;/code&gt;th and that person is out and you keep going.  You wrap
back around in a circle to the beginning and keep going until there&amp;rsquo;s only one
person left and that&amp;rsquo;s the winner.&lt;/p&gt;

&lt;p&gt;Can you figure out which position wins given &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;?  Tough to do I guess.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s simulate it instead.  Using a Queue.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n = 12&lt;/code&gt; and &lt;code&gt;k = 3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3, 6, 9, 12, 4, 8, 1, 7, 2, 11, 5.  10 is the winner.&lt;/p&gt;

&lt;p&gt;So in a queue, add them all in order.  As you process, &lt;code&gt;dequeue&lt;/code&gt; and then
&lt;code&gt;enqueue&lt;/code&gt; it to the end of the list until the &lt;code&gt;k&lt;/code&gt;th element, you &lt;code&gt;dequeue&lt;/code&gt;
but don&amp;rsquo;t &lt;code&gt;enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;implementing-a-queue&#34;&gt;Implementing a Queue&lt;/h3&gt;

&lt;p&gt;We would use a list.  We want to add at one end and remove at the other.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;LinkedList&lt;/code&gt; API in Java, the &lt;code&gt;add&lt;/code&gt; method adds to the end of the list
by default.  There&amp;rsquo;s also a &lt;code&gt;remove&lt;/code&gt; method that takes no input and by default,
removes the first element.  So these directly map to a &lt;code&gt;Queue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Java actually has a &lt;code&gt;Queue&lt;/code&gt; interface.  In the homework, we implement &lt;code&gt;MyQueue&lt;/code&gt;
which is slightly different (simplified I believe).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; actually implements &lt;code&gt;Queue&lt;/code&gt;.  So it uses &lt;code&gt;enqueue&lt;/code&gt; and &lt;code&gt;dequeue&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.LinkedList;
import java.util.Queue;

public class Josephus {
  public static void main(String[] args) {
    int n = 12;
    int k = 3;
    // Queue is an interface so we can use it as type
    // LinkedList implements Queue so this works
    // We constrain ourselves to the Queue interface which is a subset
    // of LinkedList
    Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;;
    
    // Initialize our Queue full of peeps
    for (int i = 1; i &amp;lt;= n; i++) {
      q.add(i);
    }
    
    // Keep going until there&#39;s only one person left
    while(q.size &amp;gt; 1) {
      for (int i = 0; i &amp;lt; k - 1) {
        q.add(q.remove());
      }
      // We&#39;re now at the kth element so remove it
      q.remove()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;trees&#34;&gt;Trees&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to go up to AVL trees, which is through 4.4 (check that though).&lt;/p&gt;

&lt;p&gt;Trees have a root node and zero or more sub-nodes hanging off the root node.
Each of these sub-nodes are in turn trees.&lt;/p&gt;

&lt;p&gt;Trees are like Graphs but are not cyclical (you only in one direction). Maybe
read about Graphs.&lt;/p&gt;

&lt;p&gt;Linked lists are actually Trees (kinda) with only one path to follow.&lt;/p&gt;

&lt;p&gt;The sub-nodes are called children and the root is the parent.  Nodes with no
children are called leaf nodes.  Nodes with children are called interior /
inner nodes.&lt;/p&gt;

&lt;h3 id=&#34;height-of-a-node&#34;&gt;Height of a Node&lt;/h3&gt;

&lt;p&gt;The length of a path is the number of edges we traverse (the connectors between
nodes).  The height of a node is the length of the longest path to a leaf.&lt;/p&gt;

&lt;h3 id=&#34;depth-of-a-node&#34;&gt;Depth of a Node&lt;/h3&gt;

&lt;p&gt;Depth of a node is the length of the unique path to the root.  Depth of the
root is zero.  Each level of a tree is basically increasing the depth by one.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 8: Stacks and Queues</title>
      <link>http://www.getup8.com/classes/data-structures/lecture8/</link>
      <pubDate>Mon, 03 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture8/</guid>
      <description>

&lt;h2 id=&#34;stacks-continued&#34;&gt;Stacks (continued)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;LIFO: Last In, First Out&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt; methods are central&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A Java &lt;code&gt;List&lt;/code&gt; is a doubly-linked list.  So for implementing a Stack, we don&amp;rsquo;t
care which side we add / remove from.  If it was a singly-linked list, we&amp;rsquo;d
want to choose the front so we keep &lt;em&gt;O(1)&lt;/em&gt; and not &lt;em&gt;O(N)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Stacks can also be implemented with a simple &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Popping an empty stack is sometimes referred to underflow.&lt;/p&gt;

&lt;p&gt;Can you overflow a linked-list based stack?
Not really.  Only if you actually run out of computer memory.&lt;/p&gt;

&lt;p&gt;But if you use an array, you do need to worry about overflow.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;example on board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A seven element array.  For first &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; it to location zero.
Now if we want to &lt;code&gt;push&lt;/code&gt; another 6, where do we &lt;code&gt;push&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;We need an instance variable that stores the index of the first free element of
the array.  So in this case, &lt;code&gt;top = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Every time you &lt;code&gt;push&lt;/code&gt;, you go to index top gives you, place the value,
increment &lt;code&gt;top&lt;/code&gt; by one.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;top &amp;gt;= Array.length&lt;/code&gt; we know that the array is full.  So &lt;code&gt;top&lt;/code&gt; needs to be
less than the length in order to add an element.&lt;/p&gt;

&lt;p&gt;If we want to &lt;code&gt;pop&lt;/code&gt; an element, we decrement &lt;code&gt;top&lt;/code&gt; and return the value at that
location.  We should probably use &lt;code&gt;--top&lt;/code&gt; as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Simplified implementation
pop() {
    return a[--top];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t actually have to remove the element since we&amp;rsquo;ll just overwrite it in
the future since &lt;code&gt;top&lt;/code&gt; points at that position.  We can get away with this
although it could be problematic because it would prevent that memory from
being garbage collected.  Also, if we printed the Array or did some operation
with it, we&amp;rsquo;d need to make sure to not print past &lt;code&gt;top - 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Aside from me: I think it&amp;rsquo;s better to remove it.. Maybe check to see what they
do in &lt;code&gt;LinkedList&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;queues&#34;&gt;Queues&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;FIFO.  First in, first out.  Line at the grocery store.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two main methods:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;enqueue&lt;/code&gt;: adding someone to the line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dequeue&lt;/code&gt;: removing someone from the line&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Goal is to provide the fastest way to provide these methods in these data
structures. Multiple ways to do them but how can we do them most efficiently?&lt;/p&gt;

&lt;p&gt;In implementing a queue in these data structures, can they be &lt;em&gt;O(1)&lt;/em&gt;?:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Doubly-linked list: can be &lt;em&gt;O(1)&lt;/em&gt; for both methods&lt;/li&gt;
&lt;li&gt;Singly-linked list: not really, &lt;em&gt;O(1)&lt;/em&gt; and &lt;em&gt;O(N)&lt;/em&gt; for the two methods&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Can also use an &lt;code&gt;Array&lt;/code&gt;, and again you need to beware of overflowing.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Whiteboard Example: Implementing a Queue Using an Array&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Array of length ten.&lt;/p&gt;

&lt;p&gt;So how many instance variables do we need?&lt;/p&gt;

&lt;p&gt;If one, let&amp;rsquo;s say &lt;code&gt;tail&lt;/code&gt;, doesn&amp;rsquo;t work great since we can only track one side
of the queue so we&amp;rsquo;d have to move everything over if we &lt;code&gt;dequeue&lt;/code&gt;d an
element.  It&amp;rsquo;d be &lt;em&gt;O(N)&lt;/em&gt; because of that.&lt;/p&gt;

&lt;p&gt;If two variables: &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, we can track both ends and we don&amp;rsquo;t have
to move anything around.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;tail&lt;/code&gt; becomes the length of the array, we&amp;rsquo;ve run out of space.  Before
increasing the size of the array and copying over, we should try to use the
same Array and just &amp;ldquo;wrap around&amp;rdquo;.  We can do this by adding one to &lt;code&gt;tail&lt;/code&gt; and
taking the &lt;code&gt;mod&lt;/code&gt; by the length of the &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is when a separate &lt;code&gt;size&lt;/code&gt; variable becomes useful.  It would track the
current number of elements so you can better make the decision of whether to
wrap around or increase the size of the array.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;stack-algorithms-and-use-cases&#34;&gt;Stack Algorithms and Use Cases&lt;/h2&gt;

&lt;p&gt;One good use of stacks is to reverse strings; e.g. check for palindromes.&lt;br /&gt;
e.g. &lt;em&gt;yo banana boy&lt;/em&gt;, &lt;em&gt;race car&lt;/em&gt;, &lt;em&gt;taco cat&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sample algorithm for determining if &lt;em&gt;&amp;ldquo;race car&amp;rdquo;&lt;/em&gt; is a palindrome:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For each character in the string, &lt;code&gt;push&lt;/code&gt; into stack&lt;/li&gt;
&lt;li&gt;If you have an odd number of characters, ignore the middle character; if
even, you don&amp;rsquo;t ignore&lt;/li&gt;
&lt;li&gt;Skip whitespace&lt;/li&gt;
&lt;li&gt;After the midpoint, &lt;code&gt;pop&lt;/code&gt; from the stack and compare to that character&lt;/li&gt;
&lt;li&gt;If ever it doesn&amp;rsquo;t match, you return false&lt;/li&gt;
&lt;li&gt;When you get to the end, you should check to make sure the string is empty
but this shouldn&amp;rsquo;t happen (the string or the stack?)&lt;/li&gt;
&lt;li&gt;If you &lt;code&gt;pop&lt;/code&gt; an empty stack something is wrong as well&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another example&amp;hellip;&lt;/p&gt;

&lt;p&gt;RPN Calculator: put the operands first followed by the operator (e.g. &lt;code&gt;5 3 +&lt;/code&gt;).
Parentheses aren&amp;rsquo;t needed because order of operations is explicit.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;5 3 + 2 *&lt;/code&gt; would equal &lt;code&gt;(5 + 3) * 2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try to write an algorithm to do this.&lt;br /&gt;
&lt;code&gt;apply&lt;/code&gt;: takes three arguments, two operands and an operator.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Start out with a stack.&lt;/li&gt;
&lt;li&gt;Move through the input token by token.&lt;/li&gt;
&lt;li&gt;Is the token an operator or operand?&lt;/li&gt;
&lt;li&gt;If it&amp;rsquo;s an operand, &lt;code&gt;push&lt;/code&gt; onto the stack.&lt;/li&gt;
&lt;li&gt;If it&amp;rsquo;s an operator, we &lt;code&gt;pop&lt;/code&gt; the stack twice.&lt;/li&gt;
&lt;li&gt;The first number &lt;code&gt;pop&lt;/code&gt;ped is the second operand&lt;/li&gt;
&lt;li&gt;The second number &lt;code&gt;pop&lt;/code&gt;ped is the first operand&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; the stack one more time, if the stack is not empty, you have an error&lt;/li&gt;
&lt;li&gt;Other errors?  If there is only one number and then an operand, the second
&lt;code&gt;pop&lt;/code&gt; won&amp;rsquo;t work.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;op2 = pop();
op1 = pop();
result = apply(op1, op2, +);
push(result); // Push result back onto stack and keep going
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Details of this &lt;a href=&#34;https://en.wikipedia.org/wiki/Reverse_Polish_notation#Postfix_algorithm&#34;&gt;algorithm can be found here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2 5 3 + *&lt;/code&gt; should be calculated &lt;code&gt;(5 + 3) * 2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RPN is called Postfix expression.
The way we usually do things is called Infix expressions.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;I missed the first two steps here..&lt;/li&gt;
&lt;li&gt;A token is either a number or an operator.&lt;/li&gt;
&lt;li&gt;How should we distinguish between them?&lt;/li&gt;
&lt;li&gt;We can use &lt;code&gt;split&lt;/code&gt; to turn string into an array.&lt;/li&gt;
&lt;li&gt;We can also use String Tokenizer which acts like an Iterator.  They take in a
 string and has two methods: &lt;code&gt;hasNextToken&lt;/code&gt; and &lt;code&gt;nextToken&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 7: ArrayList, LinkedList, Stacks</title>
      <link>http://www.getup8.com/classes/data-structures/lecture7/</link>
      <pubDate>Wed, 28 Sep 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture7/</guid>
      <description>

&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Cycling back to the &lt;code&gt;ArrayListIterator&lt;/code&gt; to understand how nested classes
function.&lt;/li&gt;
&lt;li&gt;Also going through implementation of &lt;code&gt;LinkedList&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Stacks and Queues.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;to-dos&#34;&gt;To Dos&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Read Chapters 3 and 4.&lt;/li&gt;
&lt;li&gt;And for me, go back to Big Java and at least skim those chapters as well.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;array-lists&#34;&gt;Array Lists&lt;/h2&gt;

&lt;p&gt;Going back to &lt;code&gt;MyArrayList&lt;/code&gt; code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iterator()&lt;/code&gt;: create a new instance of a class that implements &lt;code&gt;Iterator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ArrayListIterator&lt;/code&gt; is a nested class; it&amp;rsquo;s defined inside the &lt;code&gt;MyArrayList&lt;/code&gt;
class. It&amp;rsquo;s defined as private so that no one outside MyArrayList can
instantiate it, but &lt;code&gt;MyArrayList&lt;/code&gt; can.&lt;/p&gt;

&lt;p&gt;Purpose of an iterator is to step through a collection of any sort.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hasNext()&lt;/code&gt;: figure out if there&amp;rsquo;s a next element&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next()&lt;/code&gt;: move to next and return it&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove()&lt;/code&gt;: remove the element that we just moved past&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our iterator is &lt;em&gt;not&lt;/em&gt; &lt;code&gt;static&lt;/code&gt;.  There are two kinds of nested.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Non-&lt;code&gt;static&lt;/code&gt; is tied to the particular instance of &lt;code&gt;MyArrayList&lt;/code&gt; from
whence its generator.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one thing we need to keep track of w/ an iterator is &amp;ldquo;Where are we?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Private vars:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;: where we currently are; instantiated to zero.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;okToRemove&lt;/code&gt;: whether we can implement the &lt;code&gt;remove&lt;/code&gt; method. At the
beginning it&amp;rsquo;s not okay (since we&amp;rsquo;d remove n-1) so this is set to &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;size()&lt;/code&gt; can be accessed on &lt;code&gt;MyArrayList&lt;/code&gt; since &lt;code&gt;ArrayListIterator&lt;/code&gt; is nested.
Would it work if the nested class was &lt;code&gt;static&lt;/code&gt;?  I&amp;rsquo;m guessing no since it
wouldn&amp;rsquo;t be tied to a specific instance but I should test it!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curent++&lt;/code&gt; will evaluate the value of &lt;code&gt;current&lt;/code&gt; first and then increment it.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MyArrayList.this.remove(--current);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a method in the &lt;code&gt;MyArrayList&lt;/code&gt; to actually remove an element which is
what we actually want to call.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MyArrayList.this&lt;/code&gt; means the specific containing object.
&lt;code&gt;--current&lt;/code&gt; means we remove the item before the current one.&lt;/p&gt;

&lt;p&gt;Any Collection, which includes any List, would provide an Iterator.&lt;/p&gt;

&lt;p&gt;An Inner Class is non-static nested class.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;linked-lists&#34;&gt;Linked Lists&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;MyLinkedList&lt;/code&gt; implementation (that will be sent out?) does a doubly linked
list with sentinal nodes.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry about &lt;code&gt;modCount&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a class &lt;code&gt;LinkedList&lt;/code&gt; and you can just instantiate to create.&lt;/p&gt;

&lt;p&gt;Has two private &lt;code&gt;Node&lt;/code&gt; objects: &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node&lt;/code&gt; class is &lt;code&gt;static&lt;/code&gt; and defined in MyLinkedList.
&lt;code&gt;Node&lt;/code&gt; doesn&amp;rsquo;t have access to MyLinkedList objects (since it&amp;rsquo;s &lt;code&gt;static&lt;/code&gt;).
&lt;code&gt;next&lt;/code&gt; and &lt;code&gt;prev&lt;/code&gt; pointers to other &lt;code&gt;Node&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;doClear()&lt;/code&gt; creates end nodes and makes them point at each other.
Look at the code.&lt;/p&gt;

&lt;p&gt;Also called when &lt;code&gt;beginMarker&lt;/code&gt; and &lt;code&gt;endMarker&lt;/code&gt; already exist by the &lt;code&gt;clear&lt;/code&gt;
method.&lt;/p&gt;

&lt;p&gt;Java garbage collection! Imagine if there&amp;rsquo;s a count in memory of how many
references there are to an object.  The Java Virtual Machine reclaims the
memory of the objects that no one points to.  In other languages like C this
will give you a memory leak and you need to do it yourself.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s what happens when &lt;code&gt;clear()&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;size()&lt;/code&gt;
&lt;code&gt;isEmpty()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;add()&lt;/code&gt; Lots of them! Overloaded.
If no other info, add at the end of the list.
Another implementation takes index we want to insert something and the object
itself.&lt;/p&gt;

&lt;p&gt;In a linked list, you don&amp;rsquo;t just jump to a location, you have to iterate from
beginning to end.  So what we actually want, given an index, is the reference
to the &lt;code&gt;Node&lt;/code&gt; that exists that many steps into the linked list.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addBefore()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getNode()&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Interesting!&lt;/li&gt;
&lt;li&gt;Depending on what index is, we start from beginning or end. Doesn&amp;rsquo;t
change Big Oh&lt;/li&gt;
&lt;li&gt;Start at first element if start at beginning&lt;/li&gt;
&lt;li&gt;Start at &lt;code&gt;endMarker&lt;/code&gt; if we start at the end though since we&amp;rsquo;re inserting
before.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also have a &lt;code&gt;set&lt;/code&gt; method that also uses &lt;code&gt;getNode()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Remove methods.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Remove &lt;code&gt;Node&lt;/code&gt; p.  Basically just bypass it by changing the references of
the nodes before and after.  All you need is the reference to the node you
want to remove and you can use its &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;prev&lt;/code&gt; references!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lastly has an &lt;code&gt;iterator()&lt;/code&gt; method that returns an instance of the
&lt;code&gt;LinkedListIterator&lt;/code&gt; class that&amp;rsquo;s very similar to our &lt;code&gt;ArrayList&lt;/code&gt; iterator.
Look at this code and understand it.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;stacks&#34;&gt;Stacks&lt;/h2&gt;

&lt;p&gt;So what can we do with these things??&lt;/p&gt;

&lt;p&gt;There are other data structures built on top of these.&lt;/p&gt;

&lt;p&gt;The Stack.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can only add/remove elements from the top of a Stack&lt;/li&gt;
&lt;li&gt;Last in, first out. aka LIFO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ADT, Abstract Data Type of a Stack.
What methods does it need to have to behave like this?&lt;/p&gt;

&lt;p&gt;Adding an element is referred to as &lt;code&gt;push&lt;/code&gt;ing.
Removing an element (and returning it) is referred to &lt;code&gt;pop&lt;/code&gt;ping.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top&lt;/code&gt; or &lt;code&gt;peek&lt;/code&gt; gives you the last value without removing?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isEmpty()&lt;/code&gt;
&lt;code&gt;size()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lots of problems using just &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reversing the order&lt;/li&gt;
&lt;li&gt;Detecting palindromes: a word that&amp;rsquo;s the same backwards and forwards

&lt;ul&gt;
&lt;li&gt;If you have an even number, the first half is the second half reversed&lt;/li&gt;
&lt;li&gt;If odd, ignore middle character,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; off the second half and compare to each of the first&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is related to the Homework.  Something similar.
Need to implement a Stack.
Any List will work.&lt;/p&gt;

&lt;p&gt;If singly linked list, &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pop&lt;/code&gt; from front, all &lt;em&gt;O(1)&lt;/em&gt;, otherwise if you do
from end, it&amp;rsquo;s &lt;em&gt;O(N)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;With doubly linked list, it&amp;rsquo;s &lt;em&gt;O(1)&lt;/em&gt; from either end.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; has push / pop methods in &lt;code&gt;java.util&lt;/code&gt;.  Basically just reimplement
this along with the other functions above.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Classes</title>
      <link>http://www.getup8.com/classes/</link>
      <pubDate>Wed, 28 Sep 2016 22:28:43 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/</guid>
      <description>

&lt;h2 id=&#34;data-structures-in-java&#34;&gt;Data Structures in Java&lt;/h2&gt;

&lt;h3 id=&#34;columbia-university-coms-3134&#34;&gt;Columbia University, COMS 3134&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Fall 2016&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Columbia University: Data Structures in Java (COMS 3134)</title>
      <link>http://www.getup8.com/classes/data-structures/</link>
      <pubDate>Wed, 28 Sep 2016 22:28:43 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/</guid>
      <description>

&lt;h2 id=&#34;lecture-notes&#34;&gt;Lecture Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lecture 5&lt;/li&gt;
&lt;li&gt;Lecture 6&lt;/li&gt;
&lt;li&gt;Lecture 7&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 6: Linked Lists</title>
      <link>http://www.getup8.com/classes/data-structures/lecture6/</link>
      <pubDate>Mon, 26 Sep 2016 22:49:10 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture6/</guid>
      <description>

&lt;h2 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h2&gt;

&lt;p&gt;A few types of linked lists: singly and doubly linked.&lt;/p&gt;

&lt;h3 id=&#34;singly-linked-lists&#34;&gt;Singly Linked Lists&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Each piece of data we insert is placed in a &lt;code&gt;Node&lt;/code&gt; object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node&lt;/code&gt; class defines two instance variables

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Object reference to another &lt;code&gt;Node&lt;/code&gt;: &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t have prescribed locations in memory where each element is. You have
to start at the beginning and work your way to it using the &lt;code&gt;next&lt;/code&gt;
references.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; reference in last element of the list just points to &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linked list class has a &lt;code&gt;head&lt;/code&gt; reference to the first element of the list.  So
to get the third element, you have to keep a counter and start at the first and
go to the third using &lt;code&gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What if we want to access the nth element?  What&amp;rsquo;s Big-Oh cost?  &lt;em&gt;O(N)&lt;/em&gt;.
What about for an array? &lt;em&gt;O(const)&lt;/em&gt; or &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Linked lists suck!  At least for &lt;em&gt;get&lt;/em&gt; operations.  They&amp;rsquo;re more expensive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Node&amp;lt;AnyType&amp;gt; {
    AnyType data;
    Node&amp;lt;AnyType&amp;gt; next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class LinkedList&amp;lt;AnyType&amp;gt; {
    Node&amp;lt;AnyType&amp;gt; head;
    int size;

    // Getter
    AnyType get(int i) {
        // Initially point to beginning of list
        Node&amp;lt;AnyType&amp;gt; t = head;
        int count = 0;
        if (i &amp;gt;= size) {
            // throw exception..
        }
        while(count &amp;lt; i) {
            count++;
            // You&#39;ll get a null pointer exception here if `i` is greater than
            // the number of nodes in the list
            t = t.next;
        }
        return t.data;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what would the cost be to insert a new value at the beginning of the list?
Order 1. &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a new &lt;code&gt;Node&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Put data into it&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;next&lt;/code&gt; equal to &lt;code&gt;head&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Make &lt;code&gt;head&lt;/code&gt; refer to it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What about if you want to insert at the end?  You need to iterate all the way
to the end since you only have a reference to &lt;code&gt;head&lt;/code&gt;.  So it&amp;rsquo;s &lt;em&gt;O(N)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What about the middle?  &lt;em&gt;O(N)&lt;/em&gt; still.  But once I have the reference to the
node I want to insert after already, it&amp;rsquo;s easy and &lt;em&gt;O(1)&lt;/em&gt;.  Remember that.  So
if you&amp;rsquo;re already moving across the list, and you decide you want to insert
something, it&amp;rsquo;s easy and cheap.&lt;/p&gt;

&lt;p&gt;Another benefit: We don&amp;rsquo;t need to specify how large this list is going to be.&lt;/p&gt;

&lt;p&gt;This is a building block for other data structures.&lt;/p&gt;

&lt;h3 id=&#34;doubly-linked-lists&#34;&gt;Doubly Linked Lists&lt;/h3&gt;

&lt;p&gt;You have a &lt;code&gt;head&lt;/code&gt; and a &lt;code&gt;tail&lt;/code&gt;.  You add a &lt;code&gt;previous&lt;/code&gt; pointer.  So you can move
in both directions, forwards or backwards.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt; interface.  &lt;code&gt;ListIterator&lt;/code&gt; interface adds an extra bit that allows
you to move forward or backward; it exploits the doubly linked list.&lt;/p&gt;

&lt;p&gt;Uses &amp;ldquo;sentinal nodes&amp;rdquo;.  The head data has no data.  The first piece of data is
actually at &lt;code&gt;head.next()&lt;/code&gt;.  The tail also doesn&amp;rsquo;t have any data.  The last node
is &lt;code&gt;tail.previous()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nodes now have three fields:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;previous&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An empty doubly linked list:
&lt;code&gt;null&lt;/code&gt; -&amp;gt; &lt;code&gt;head&lt;/code&gt; -&amp;gt; &lt;code&gt;tail&lt;/code&gt; -&amp;gt; &lt;code&gt;null&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re going to insert data, we&amp;rsquo;d insert after &lt;code&gt;head&lt;/code&gt; or before &lt;code&gt;tail&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;Node&lt;/code&gt;, populated with &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;previous&lt;/code&gt; points to &lt;code&gt;head&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; points to &lt;code&gt;head.next&lt;/code&gt; (instead of &lt;code&gt;tail&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head.next.previous&lt;/code&gt; (or &lt;code&gt;tail.previous&lt;/code&gt;) points to it&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head.next&lt;/code&gt; points to it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can actually implement both types with sentinal nodes (singly and doubly).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 5: Iterators and Interfaces</title>
      <link>http://www.getup8.com/classes/data-structures/lecture5/</link>
      <pubDate>Wed, 21 Sep 2016 22:49:15 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture5/</guid>
      <description>

&lt;p&gt;A list is a type of collection.&lt;/p&gt;

&lt;p&gt;A collection is TODO: fill me in.&lt;/p&gt;

&lt;h2 id=&#34;iterators&#34;&gt;Iterators&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt; is another class that attaches to a particular &lt;code&gt;Collection&lt;/code&gt; used to
go through the &lt;code&gt;Collection&lt;/code&gt;, item by item.&lt;/p&gt;

&lt;p&gt;Can have multiple iterators attached to a collection moving at different
speeds, different locations.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java.util.Iterator&lt;/code&gt; is an &lt;em&gt;interface&lt;/em&gt;, it provides method requirements.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt; method is a factory method and its job is to construct a class. It&amp;rsquo;s
job is to create some &lt;code&gt;Iterator&lt;/code&gt; object that iterates across the collection and
returns something.&lt;/p&gt;

&lt;p&gt;An iterator is its own object of type &lt;code&gt;Iterator&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is all in chapter 3 of the book..&lt;/p&gt;

&lt;p&gt;Iterators have 3 methods:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;boolean hasNext()&lt;/code&gt; (if true, move on to next, if false, end of list)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;AnyType&amp;gt; next()&lt;/code&gt;: returns current element (telling where we are),
 advances to next&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void remove()&lt;/code&gt;: remove the item? or the iterator? think the latter.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while hasNext() == True:
    next()
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;lists&#34;&gt;Lists&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt; interface extends &lt;code&gt;Collection&lt;/code&gt;.  So all &lt;code&gt;Collection&lt;/code&gt; methods must be
(and are) included in List.&lt;/p&gt;

&lt;p&gt;So the &lt;code&gt;List&lt;/code&gt; interface adds additional methods to take advantage of ordered
space.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ListIterator&lt;/code&gt; is same as &lt;code&gt;Iterator&lt;/code&gt; but can move forward/backward since lists
have an order (&lt;code&gt;Collection&lt;/code&gt;s do not)&lt;/p&gt;

&lt;p&gt;Some mumbo jumbo about generics and objects and using int vs Integer???&lt;/p&gt;

&lt;p&gt;Advanced for loops expect an iterable / iterator. (&lt;code&gt;a.iterator()&lt;/code&gt;)&lt;br /&gt;
It creates an iterator and uses it to go through.&lt;br /&gt;
Understand how to make something work in an advanced for loop.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt; is generic so defaults to object.  Need to cast it like
&lt;code&gt;java.util.Iterator&amp;lt;Integer&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;arraylists&#34;&gt;ArrayLists&lt;/h2&gt;

&lt;p&gt;When we create an &lt;code&gt;ArrayList&lt;/code&gt;, we need to preallocate the size (let&amp;rsquo;s say 10
elements) and keep track of the first empty location.  So on instantiation,
it&amp;rsquo;s location zero.  We don&amp;rsquo;t know how long it&amp;rsquo;s going to be.&lt;/p&gt;

&lt;p&gt;Adding elements at end of list is &lt;em&gt;O(1)&lt;/em&gt; operation until you fill up the list
(the preallocated size) and then it&amp;rsquo;s &lt;em&gt;O(n)&lt;/em&gt; to copy it to the new array.&lt;/p&gt;

&lt;p&gt;So how big do we make it when we need a larger list?  Wasteful to just make it
11 since it&amp;rsquo;s quite possible to make it 12 later.&lt;/p&gt;

&lt;p&gt;Somewhat randomly, they multiply by 1.5.  Or sometimes 2.&lt;/p&gt;

&lt;p&gt;Removing elements also &lt;em&gt;O(1)&lt;/em&gt;. So is changing a specific element.&lt;/p&gt;

&lt;p&gt;What if you want to insert an element in the middle or beginning?  You have to
copy everything and move it over.  So &lt;em&gt;O(n)&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;On Canvas there is a download of all the code in the textbook.&lt;/p&gt;

&lt;p&gt;Difference between &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;implements?&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;implements Iterator&lt;/code&gt;..&lt;/p&gt;

&lt;p&gt;&lt;code&gt;theSize&lt;/code&gt; is how many items are filled up.
Length of &lt;code&gt;theItems&lt;/code&gt; is how long the &lt;code&gt;ArrayList&lt;/code&gt; is.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ensureCapacity()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When creating the array, you construct an array of objects and then cast it to
generics. The compiler doesn&amp;rsquo;t know how to create an array of generics.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;By starting at the end with &lt;code&gt;add()&lt;/code&gt; you don&amp;rsquo;t have to move anything (or iterate
through anything) if you&amp;rsquo;re adding to the end.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ArrayListIterator()&lt;/code&gt; is not provided by Java, need to implement ourselves.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://www.getup8.com/about/</link>
      <pubDate>Thu, 01 Sep 2016 22:28:43 -0400</pubDate>
      
      <guid>http://www.getup8.com/about/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m Alex.  Grew up in San Diego and live in New York.&lt;/p&gt;

&lt;p&gt;I started this blog in the fall of 2016 because I&amp;rsquo;ve had this domain name for
a long time and wanted to do something with it.  I also wanted a place to
document different things I was learning or interested in.  I also just thought
I needed a blog because well, everyone else has one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Get Up 8&lt;/em&gt; comes from the ancient proverb:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Fall seven times, get up eight.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It makes no sense whatsoever but my good friend John told me about it in
college and I&amp;rsquo;ve always loved it anyway.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Blogging in Hugo</title>
      <link>http://www.getup8.com/post/blogging-in-hugo/</link>
      <pubDate>Tue, 30 Aug 2016 22:00:43 -0400</pubDate>
      
      <guid>http://www.getup8.com/post/blogging-in-hugo/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; is a &amp;ldquo;Fast &amp;amp; Modern Website Engine&amp;rdquo; written in the
Go programming language.  It&amp;rsquo;s what I&amp;rsquo;ve chosen to write this blog in because,
well, it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;is new(ish)&lt;/li&gt;
&lt;li&gt;has an &lt;a href=&#34;https://github.com/spf13/hugo&#34;&gt;active community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;is relatively simple&lt;/li&gt;
&lt;li&gt;can deploy easily to &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt; (free hosting yo!)&lt;/li&gt;
&lt;li&gt;is fast&lt;/li&gt;
&lt;li&gt;has some &lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;beautiful, modern, responsive (and might I add, free) themes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;is written in &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;, which I kinda wanted to learn (and started at the Googs)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Below is a quick start guide to get blogging using Hugo and GitHub User Pages.
I assume you&amp;rsquo;ve downloaded and installed Hugo and have a GitHub account.&lt;/p&gt;

&lt;p&gt;I also assume you&amp;rsquo;ve created the base blog directory, and added a theme.  There
are great instructions in the &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;Hugo Quickstart Guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So now you have Hugo locally and you&amp;rsquo;re ready to actually get something on the
web!&lt;/p&gt;

&lt;h2 id=&#34;step-1-create-the-github-respositories&#34;&gt;Step 1: Create the GitHub Respositories&lt;/h2&gt;

&lt;p&gt;The way I decided to do it was to create two separate GitHub respositories, one
to keep my raw Hugo source and then the GitHub Pages one to deploy the compiled
HTML to.&lt;/p&gt;

&lt;p&gt;In my case, that meant setting up:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/getup8/getup8.github.io&#34;&gt;https://github.com/getup8/getup8.github.io&lt;/a&gt; - my GitHub User Page
 respository and where we&amp;rsquo;ll story the generated static files for the blog&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/getup8/getup8-hugo&#34;&gt;https://github.com/getup8/getup8-hugo&lt;/a&gt; for the Hugo source&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Create both of those.  For the first, you&amp;rsquo;ll want to follow the instructions
&lt;a href=&#34;https://pages.github.com/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;step-2-set-up-git-and-local-directories&#34;&gt;Step 2: Set up Git and Local Directories&lt;/h2&gt;

&lt;p&gt;Now you&amp;rsquo;ll want to set up local directories that will tie to each of these
repositories.  So create a directory named &lt;code&gt;blog&lt;/code&gt; or something of that sort
and from within that directory run:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/getup8/getup8.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/getup8/getup8-hugo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will create and initialize two local repositories.  Easy peasy.&lt;/p&gt;

&lt;h2 id=&#34;step-3-set-up-hugo&#34;&gt;Step 3: Set up Hugo&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve followed the Hugo QuickStart guide, you have the Hugo directory
structure set up elsewhere and you&amp;rsquo;ve downloaded a theme, etc.  Copy those
files into your local source respository (e.g. &lt;code&gt;getup-hugo/&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;It should work just the same there as it was elsewhere.&lt;/p&gt;

&lt;h2 id=&#34;step-4-create-a-blog-post&#34;&gt;Step 4: Create a Blog Post&lt;/h2&gt;

&lt;p&gt;From within the local blog directory (&lt;code&gt;getup8-hugo&lt;/code&gt;), create a new post by
running this on the command line:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new post/testing.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;step-5-write-the-post&#34;&gt;Step 5: Write the Post&lt;/h2&gt;

&lt;p&gt;Well, this is the easy part.  Open that file (&lt;code&gt;getup8-hugo/content/post/testing.md&lt;/code&gt;)
and write the dang post using markdown!  Maybe for now just put &amp;ldquo;Test&amp;rdquo; in the
content section.&lt;/p&gt;

&lt;h2 id=&#34;step-6-preview-the-post-locally&#34;&gt;Step 6: Preview the Post Locally&lt;/h2&gt;

&lt;p&gt;To preview the draft, run the following:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo server -t hugo-cactus-theme --buildDrafts&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And then visit &lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;step-7-undraft-the-post&#34;&gt;Step 7: Undraft the Post&lt;/h2&gt;

&lt;p&gt;All looks good?  Undraft the post:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo undraft content/post/blogging-in-hugo.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Alternatively, at the top of the markdown file in the TOML section, just
change &lt;code&gt;draft = true&lt;/code&gt; to &lt;code&gt;draft = false&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;step-8-commit-your-changes-and-push&#34;&gt;Step 8: Commit Your Changes and Push&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Add all files to staging
git add --all

# Check the status, make sure files have been added
git status

# Commit locally
git commit -m &amp;quot;Test post&amp;quot;

# Push to GitHub repository
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-9-deploy-to-github-pages&#34;&gt;Step 9: Deploy to GitHub Pages&lt;/h2&gt;

&lt;p&gt;Almost there but you&amp;rsquo;re not done yet.  This is the most important part.  We
now need to generate our static files and push them to our GitHub Pages
repository.&lt;/p&gt;

&lt;p&gt;From within the blog source directory again, execute the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Generate the static files with your chosen theme and most
# importantly, direct them to your *other* directory
hugo -t hugo-cactus-theme -d ../getup8.github.io

# Now move to that directory
cd ../getup8.github.io

# And commit all those files
git add --all
git commit -m &amp;quot;Test post&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can actually just wrap up all those commands into a shell script to make it
much easier to deploy in the future.  Something like this:&lt;/p&gt;

&lt;p&gt;&lt;div style=&#34;margin-bottom:-1rem;&#34;&gt;&lt;em&gt;deploy.sh&lt;/em&gt;&lt;/div&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

# Change this to the relative path of your other directory
PAGES_PATH=&amp;quot;../getup8.github.io&amp;quot;
DIR=&amp;quot;$( cd &amp;quot;$( dirname &amp;quot;${BASH_SOURCE[0]}&amp;quot; )&amp;quot; &amp;amp;&amp;amp; pwd )&amp;quot;

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build project and direct the output to the GitHub Pages repository
hugo -d ${PAGES_PATH}

# Now move to that directory
cd ${PAGES_PATH}

# Set commit message to first arg or default.
MSG=&amp;quot;Rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then MSG=&amp;quot;$1&amp;quot;
fi

# Add, commit and push changes.
git add --all
git commit -m &amp;quot;${MSG}&amp;quot;
git push -u origin master

# Come Back
cd ${DIR}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now after commiting changes, you can deploy to the blog in one step:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;./deploy.sh &amp;quot;Initial blog post&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;fin&#34;&gt;Fin!&lt;/h2&gt;

&lt;p&gt;With a little luck, when you browse to your blog&amp;rsquo;s URL, you&amp;rsquo;ll see your
beautiful test post.&lt;/p&gt;

&lt;p&gt;Hope this was helpful, let me know if you have any trouble.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>