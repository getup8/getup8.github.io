<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>data structures on GetUp8</title>
    <link>http://www.getup8.com/tags/data-structures/</link>
    <description>Recent content in data structures on GetUp8</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Oct 2016 22:36:00 -0400</lastBuildDate>
    <atom:link href="http://www.getup8.com/tags/data-structures/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Lecture 9: Stacks, Queues, Trees</title>
      <link>http://www.getup8.com/classes/data-structures/lecture9/</link>
      <pubDate>Wed, 05 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture9/</guid>
      <description>

&lt;h2 id=&#34;stacks-and-postfix-infix-expression-continued&#34;&gt;Stacks and Postfix / Infix Expression (continued)&lt;/h2&gt;

&lt;p&gt;Postfix and Infix expressions.&lt;/p&gt;

&lt;p&gt;If we have an infix expression, we scan through each token and when we
encounter an operator, we don&amp;rsquo;t have all of the operands.  So we &lt;code&gt;push&lt;/code&gt; that
operator onto the stack (as long as it&amp;rsquo;s empty).  If it&amp;rsquo;s not empty and there
are other operators, we need to figure out order of operations.&lt;/p&gt;

&lt;p&gt;So we look at the top of the stack and check if it has a lower precedence of
the one we&amp;rsquo;re processing, we &lt;code&gt;push&lt;/code&gt; on to the stack.  If it&amp;rsquo;s higher, we &lt;code&gt;pop&lt;/code&gt;
it off and do the operation and keep checking until the stack is empty or we
find an operator of lower precedence.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a * b - c + d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a&lt;/li&gt;
&lt;li&gt;stack = [*]&lt;/li&gt;
&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;stack = [-, *]&lt;/li&gt;
&lt;li&gt;c&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(-)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stack = [+, *]&lt;/li&gt;
&lt;li&gt;&amp;lt;run out of tokens]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;a b * c - d +&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What about parentheses?  You &lt;code&gt;push&lt;/code&gt; open parentheses onto the stack.
Eventually you reach the end of the parentheses; when you do, you keep &lt;code&gt;pop&lt;/code&gt;ing
the stack until you get the open parentheses.  Then you &lt;code&gt;pop&lt;/code&gt; it out and get
rid of both parentheses and keep going.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a + b * c + (d * e + f) * g&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a&lt;/li&gt;
&lt;li&gt;[+]&lt;/li&gt;
&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;[*, +]&lt;/li&gt;
&lt;li&gt;c&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[+]&lt;/li&gt;
&lt;li&gt;[(, +]&lt;/li&gt;
&lt;li&gt;d&lt;/li&gt;
&lt;li&gt;[*, (, +]&lt;/li&gt;
&lt;li&gt;e&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[+, (, +]&lt;/li&gt;
&lt;li&gt;f&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;g&lt;/li&gt;
&lt;li&gt;[*, +]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop(+)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;a b c * + d e * f + g * +&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Stacks are used in programs (all programs?) and are very present in how
recursion works.  Each level of the recursion pushes the step onto the stack
until we return and we start popping them all off.&lt;/p&gt;

&lt;h2 id=&#34;queues-and-the-josephus-game&#34;&gt;Queues and the Josephus Game&lt;/h2&gt;

&lt;p&gt;You have &lt;code&gt;n&lt;/code&gt; items in a circle, in a specific order.&lt;/p&gt;

&lt;p&gt;Then you have a second value &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You count from the first to the &lt;code&gt;k&lt;/code&gt;th person.  That person is then out.  Then
you count the next &lt;code&gt;k&lt;/code&gt;th and that person is out and you keep going.  You wrap
back around in a circle to the beginning and keep going until there&amp;rsquo;s only one
person left and that&amp;rsquo;s the winner.&lt;/p&gt;

&lt;p&gt;Can you figure out which position wins given &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;?  Tough to do I guess.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s simulate it instead.  Using a Queue.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 3&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n = 12&lt;/code&gt; and &lt;code&gt;k = 3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3, 6, 9, 12, 4, 8, 1, 7, 2, 11, 5.  10 is the winner.&lt;/p&gt;

&lt;p&gt;So in a queue, add them all in order.  As you process, &lt;code&gt;dequeue&lt;/code&gt; and then
&lt;code&gt;enqueue&lt;/code&gt; it to the end of the list until the &lt;code&gt;k&lt;/code&gt;th element, you &lt;code&gt;dequeue&lt;/code&gt;
but don&amp;rsquo;t &lt;code&gt;enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;implementing-a-queue&#34;&gt;Implementing a Queue&lt;/h3&gt;

&lt;p&gt;We would use a list.  We want to add at one end and remove at the other.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;LinkedList&lt;/code&gt; API in Java, the &lt;code&gt;add&lt;/code&gt; method adds to the end of the list
by default.  There&amp;rsquo;s also a &lt;code&gt;remove&lt;/code&gt; method that takes no input and by default,
removes the first element.  So these directly map to a Queue.&lt;/p&gt;

&lt;p&gt;Java actually has a Queue interface.  In the homework, we implement &lt;code&gt;MyQueue&lt;/code&gt;
which is slightly different (simplified I believe).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; actually implements &lt;code&gt;Queue&lt;/code&gt;.  So it uses &lt;code&gt;enqueue&lt;/code&gt; and &lt;code&gt;dequeue&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.LinkedList;
import java.util.Queue;

public class Josephus {
  public static void main(String[] args) {
    int n = 12;
    int k = 3;
    // Queue is an interface so we can use it as type
    // LinkedList implements Queue so this works
    // We constrain ourselves to the Queue interface which is a subset
    // of LinkedList
    Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;;
    
    // Initialize our Queue full of peeps
    for (int i = 1; i &amp;lt;= n; i++) {
      q.add(i);
    }
    
    // Keep going until there&#39;s only one person left
    while(q.size &amp;gt; 1) {
      for (int i = 0; i &amp;lt; k - 1) {
        q.add(q.remove());
      }
      // We&#39;re now at the kth element so remove it
      q.remove()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;trees&#34;&gt;Trees&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to go up to AVL trees, which is through 4.4 (check that though).&lt;/p&gt;

&lt;p&gt;Trees have a root node and zero or more sub-nodes hanging off the root node.
Each of these sub-nodes are in turn trees.&lt;/p&gt;

&lt;p&gt;Trees are like Graphs but are not cyclical (you only in one direction). Maybe
read about Graphs.&lt;/p&gt;

&lt;p&gt;Linked lists are actually Trees (kinda) with only one path to follow.&lt;/p&gt;

&lt;p&gt;The sub-nodes are called children and the root is the parent.  Nodes with no
children are called leaf nodes.  Nodes with children are called interior /
inner nodes.&lt;/p&gt;

&lt;h3 id=&#34;height-of-a-node&#34;&gt;Height of a Node&lt;/h3&gt;

&lt;p&gt;The length of a path is the number of edges we traverse (the connectors between
nodes).  The height of a node is the length of the longest path to a leaf.&lt;/p&gt;

&lt;h3 id=&#34;depth-of-a-node&#34;&gt;Depth of a Node&lt;/h3&gt;

&lt;p&gt;Depth of a node is the length of the unique path to the root.  Depth of the
root is zero.  Each level of a tree is basically increasing the depth by one.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 8: Stacks</title>
      <link>http://www.getup8.com/classes/data-structures/lecture8/</link>
      <pubDate>Mon, 03 Oct 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture8/</guid>
      <description>

&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;

&lt;h3 id=&#34;stacks-continued&#34;&gt;Stacks (continued)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LIFO: Last In, First Out&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt; methods are central&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A Java &lt;code&gt;List&lt;/code&gt; is a doubly-linked list.  So for implementing a Stack, we don&amp;rsquo;t
care which side we add / remove from.  If it was a singly-linked list, we&amp;rsquo;d
want to choose the front so we keep &lt;em&gt;O(1)&lt;/em&gt; and not &lt;em&gt;O(N)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Stacks can also be implemented with a simple &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Popping an empty stack is sometimes referred to underflow.&lt;/p&gt;

&lt;p&gt;Can you overflow a linked-list based stack?
Not really.  Only if you actually run out of computer memory.&lt;/p&gt;

&lt;p&gt;But if you use an array, you do need to worry about overflow.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;example on board&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A seven element array.  For first &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; it to location zero.
Now if we want to &lt;code&gt;push&lt;/code&gt; another 6, where do we &lt;code&gt;push&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;We need an instance variable that stores the index of the first free element of
the array.  So in this case, &lt;code&gt;top = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Every time you &lt;code&gt;push&lt;/code&gt;, you go to index top gives you, place the value,
increment &lt;code&gt;top&lt;/code&gt; by one.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;top &amp;gt;= Array.length&lt;/code&gt; we know that the array is full.  So &lt;code&gt;top&lt;/code&gt; needs to be
less than the length in order to add an element.&lt;/p&gt;

&lt;p&gt;If we want to &lt;code&gt;pop&lt;/code&gt; an element, we decrement &lt;code&gt;top&lt;/code&gt; and return the value at that
location.  We should probably use &lt;code&gt;--top&lt;/code&gt; as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Simplified implementation
pop() {
    return a[--top];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t actually have to remove the element since we&amp;rsquo;ll just overwrite it in
the future since &lt;code&gt;top&lt;/code&gt; points at that position.  We can get away with this
although it could be problematic because it would prevent that memory from
being garbage collected.  Also, if we printed the Array or did some operation
with it, we&amp;rsquo;d need to make sure to not print past &lt;code&gt;top - 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Aside from me: I think it&amp;rsquo;s better to remove it.. Maybe check to see what they
do in &lt;code&gt;LinkedList&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;queues-continued&#34;&gt;Queues (continued)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;FIFO.  First in, first out.  Line at the grocery store.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two main methods:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;enqueue&lt;/code&gt;: adding someone to the line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dequeue&lt;/code&gt;: removing someone from the line&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Goal is to provide the fastest way to provide these methods in these data
structures. Multiple ways to do them but how can we do them most efficiently?&lt;/p&gt;

&lt;p&gt;In implementing a queue in these data structures, can they be &lt;em&gt;O(1)&lt;/em&gt;?:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Doubly-linked list: can be &lt;em&gt;O(1)&lt;/em&gt; for both methods&lt;/li&gt;
&lt;li&gt;Singly-linked list: not really, &lt;em&gt;O(1)&lt;/em&gt; and &lt;em&gt;O(N)&lt;/em&gt; for the two methods&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Can also use an &lt;code&gt;Array&lt;/code&gt;, and again you need to beware of overflowing.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Whiteboard Example: Implementing a Queue Using an Array&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Array of length ten.&lt;/p&gt;

&lt;p&gt;So how many instance variables do we need?&lt;/p&gt;

&lt;p&gt;If one, let&amp;rsquo;s say &lt;code&gt;tail&lt;/code&gt;, doesn&amp;rsquo;t work great since we can only track one side
of the queue so we&amp;rsquo;d have to move everything over if we &lt;code&gt;dequeue&lt;/code&gt;d an
element.  It&amp;rsquo;d be O(N) because of that.&lt;/p&gt;

&lt;p&gt;If two variables: &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, we can track both ends and we don&amp;rsquo;t have
to move anything around.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;tail&lt;/code&gt; becomes the length of the array, we&amp;rsquo;ve run out of space.  Before
increasing the size of the array and copying over, we should try to use the
same Array and just &amp;ldquo;wrap around&amp;rdquo;.  We can do this by adding one to &lt;code&gt;tail&lt;/code&gt; and
taking the &lt;code&gt;mod&lt;/code&gt; by the length of the &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is when a separate &lt;code&gt;size&lt;/code&gt; variable becomes useful.  It would track the
current number of elements so you can better make the decision of whether to
wrap around or increase the size of the array.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;stack-algorithms&#34;&gt;Stack Algorithms&lt;/h3&gt;

&lt;p&gt;One good use of stacks is to reverse strings; e.g. check for palindromes.&lt;br /&gt;
e.g. &lt;em&gt;yo banana boy&lt;/em&gt;, &lt;em&gt;race car&lt;/em&gt;, &lt;em&gt;taco cat&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sample algorithm for determining if &lt;code&gt;race car&lt;/code&gt; is a palindrome:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For each character in the string, &lt;code&gt;push&lt;/code&gt; into stack&lt;/li&gt;
&lt;li&gt;If you have an odd number of characters, ignore the middle character; if
even, you don&amp;rsquo;t ignore&lt;/li&gt;
&lt;li&gt;Skip whitespace&lt;/li&gt;
&lt;li&gt;After the midpoint, &lt;code&gt;pop&lt;/code&gt; from the stack and compare to that character&lt;/li&gt;
&lt;li&gt;If ever it doesn&amp;rsquo;t match, you return false&lt;/li&gt;
&lt;li&gt;When you get to the end, you should check to make sure the string is empty
but this shouldn&amp;rsquo;t happen (the string or the stack?)&lt;/li&gt;
&lt;li&gt;If you pop an empty stack something is wrong as well&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another example&amp;hellip;&lt;/p&gt;

&lt;p&gt;RPN Calculator: put the operands first followed by the operator (e.g. 5 3 +).
Parentheses aren&amp;rsquo;t needed because order of operations is explicit.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;5 3 + 2 *&lt;/code&gt; would equal &lt;code&gt;(5 + 3) * 2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try to write an algorithm to do this.&lt;br /&gt;
&lt;code&gt;apply&lt;/code&gt;: takes three arguments, two operands and an operator.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Start out with a stack.&lt;/li&gt;
&lt;li&gt;Move through the input token by token.&lt;/li&gt;
&lt;li&gt;Is the token an operator or operand?&lt;/li&gt;
&lt;li&gt;If it&amp;rsquo;s an operand, &lt;code&gt;push&lt;/code&gt; onto the stack.&lt;/li&gt;
&lt;li&gt;If it&amp;rsquo;s an operator, we &lt;code&gt;pop&lt;/code&gt; the stack twice.&lt;/li&gt;
&lt;li&gt;The first number popped is the second operand&lt;/li&gt;
&lt;li&gt;The second number popped is the first operand&lt;/li&gt;
&lt;li&gt;Pop the stack one more time, if the stack is not empty, you have an error&lt;/li&gt;
&lt;li&gt;Other errors?  If there is only one number and then an operand, the second
&lt;code&gt;pop&lt;/code&gt; won&amp;rsquo;t work.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;op2 = pop();
op1 = pop();
result = apply(op1, op2, +);
push(result); // Push result back onto stack and keep going
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Details of this &lt;a href=&#34;https://en.wikipedia.org/wiki/Reverse_Polish_notation#Postfix_algorithm&#34;&gt;algorithm can be found here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2 5 3 + *&lt;/code&gt; should be calculated &lt;code&gt;(5 + 3) * 2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RPN is called Postfix expression.
The way we usually do things is called Infix expressions.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A token is either a number or an operator.&lt;/li&gt;
&lt;li&gt;How should we distinguish between them?&lt;/li&gt;
&lt;li&gt;We can use &lt;code&gt;split&lt;/code&gt; to turn string into an array.&lt;/li&gt;
&lt;li&gt;We can also use String Tokenizer which acts like an Iterator.  They take in a
 string and has two methods: &lt;code&gt;hasNextToken&lt;/code&gt; and &lt;code&gt;nextToken&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 7: ArrayList, LinkedList, Stacks</title>
      <link>http://www.getup8.com/classes/data-structures/lecture7/</link>
      <pubDate>Wed, 28 Sep 2016 22:36:00 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture7/</guid>
      <description>

&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Cycling back to the ArrayListIterator to understand how nested classes
function.&lt;/li&gt;
&lt;li&gt;Also going through implementation of LinkedList.&lt;/li&gt;
&lt;li&gt;Stacks and Queues.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;to-dos&#34;&gt;To Dos&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Read Chapters 3 and 4.&lt;/li&gt;
&lt;li&gt;And for me, go back to Big Java and at least skim those chapters as well.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;array-lists&#34;&gt;Array Lists&lt;/h2&gt;

&lt;p&gt;Going back to &lt;code&gt;MyArrayList&lt;/code&gt; code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iterator()&lt;/code&gt;: create a new instance of a class that implements &lt;code&gt;Iterator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ArrayListIterator&lt;/code&gt; is a nested class; it&amp;rsquo;s defined inside the &lt;code&gt;MyArrayList&lt;/code&gt;
class. It&amp;rsquo;s defined as private so that no one outside MyArrayList can
instantiate it, but &lt;code&gt;MyArrayList&lt;/code&gt; can.&lt;/p&gt;

&lt;p&gt;Purpose of an iterator is to step through a collection of any sort.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hasNext(): figure out if there&amp;rsquo;s a next element&lt;/li&gt;
&lt;li&gt;next(): move to next and return it&lt;/li&gt;
&lt;li&gt;remove(): remove the element that we just moved past&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our iterator is &lt;em&gt;not&lt;/em&gt; &lt;code&gt;static&lt;/code&gt;.  There are two kinds of nested.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Non-&lt;code&gt;static&lt;/code&gt; is tied to the particular instance of MyArrayList from whence it
is generator.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one thing we need to keep track of w/ an iterator is &amp;ldquo;Where are we?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Private vars:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;: where we currently are; instantiated to zero.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;okToRemove&lt;/code&gt;: whether we can implement the &lt;code&gt;remove&lt;/code&gt; method. At the
beginning it&amp;rsquo;s not okay (since we&amp;rsquo;d remove n-1) so this is set to &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;size()&lt;/code&gt; can be accessed on &lt;code&gt;MyArrayList&lt;/code&gt; since &lt;code&gt;ArrayListIterator&lt;/code&gt; is nested.
Would it work if the nested class was &lt;code&gt;static&lt;/code&gt;?  I&amp;rsquo;m guessing no since it
wouldn&amp;rsquo;t be tied to a specific instance but I should test it!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curent++&lt;/code&gt; will evaluate the value of &lt;code&gt;current&lt;/code&gt; first and then increment it.&lt;/p&gt;

&lt;p&gt;MyArrayList.this.remove(&amp;ndash;current);&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a method in the MyArrayList to actually remove an element which is
what we actually want to call.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MyArrayList.this&lt;/code&gt; means the specific containing object.
&lt;code&gt;--current&lt;/code&gt; means we remove the item before the current one.&lt;/p&gt;

&lt;p&gt;Any Collection, which includes any List, would provide an Iterator.&lt;/p&gt;

&lt;p&gt;An Inner Class is non-static nested class.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Back to Linked Lists.&lt;/p&gt;

&lt;p&gt;MyLinkedList implementation (that will be sent out?) does a doubly linked list
with sentinal nodes.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry about &lt;code&gt;modCount&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a class LinkedList and you can just instantiate to create.&lt;/p&gt;

&lt;p&gt;Has two private Node objects: begin and end.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node&lt;/code&gt; class is &lt;code&gt;static&lt;/code&gt; and defined in MyLinkedList.
&lt;code&gt;Node&lt;/code&gt; doesn&amp;rsquo;t have access to MyLinkedList objects (since it&amp;rsquo;s &lt;code&gt;static&lt;/code&gt;).
&lt;code&gt;next&lt;/code&gt; and &lt;code&gt;prev&lt;/code&gt; pointers to other &lt;code&gt;Node&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;doClear()&lt;/code&gt; creates end nodes and makes them point at each other.
Look at the code.&lt;/p&gt;

&lt;p&gt;Also called when &lt;code&gt;beginMarker&lt;/code&gt; and &lt;code&gt;endMarker&lt;/code&gt; already exist by the &lt;code&gt;clear&lt;/code&gt;
method.&lt;/p&gt;

&lt;p&gt;Java garbage collection! Imagine if there&amp;rsquo;s a count in memory of how many
references there are to an object.  The Java Virtual Machine reclaims the
memory of the objects that no one points to.  In other languages like C this
will give you a memory leak and you need to do it yourself.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s what happens when &lt;code&gt;clear()&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;size()&lt;/code&gt;
&lt;code&gt;isEmpty()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;add()&lt;/code&gt; Lots of them! Overloaded.
If no other info, add at the end of the list.
Another implementation takes index we want to insert something and the object
itself.&lt;/p&gt;

&lt;p&gt;In a linked list, you don&amp;rsquo;t just jump to a location, you have to iterate from
beginning to end.  So what we actually want, given an index, is the reference
to the &lt;code&gt;Node&lt;/code&gt; that exists that many steps into the linked list.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addBefore()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getNode()&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Interesting!&lt;/li&gt;
&lt;li&gt;Depending on what index is, we start from beginning or end. Doesn&amp;rsquo;t
change Big Oh&lt;/li&gt;
&lt;li&gt;Start at first element if start at beginning&lt;/li&gt;
&lt;li&gt;Start at endMarker if we start at the end though since we&amp;rsquo;re inserting
before.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also have a &lt;code&gt;set&lt;/code&gt; method that also uses &lt;code&gt;getNode()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Remove methods.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Remove &lt;code&gt;Node&lt;/code&gt; p.  Basically just bypass it by changing the references of
the nodes before and after.  All you need is the reference to the node you
want to remove and you can use its &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;prev&lt;/code&gt; references!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lastly has an &lt;code&gt;iterator()&lt;/code&gt; method that returns an instance of the
&lt;code&gt;LinkedListIterator&lt;/code&gt; class that&amp;rsquo;s very similar to our &lt;code&gt;ArrayList&lt;/code&gt; iterator.
Look at this code and understand it.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;So what can we do with these things??&lt;/p&gt;

&lt;p&gt;There are other data structures built on top of these.&lt;/p&gt;

&lt;p&gt;The Stack.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can only add/remove elements from the top of a Stack&lt;/li&gt;
&lt;li&gt;Last in, first out. aka LIFO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ADT, Abstract Data Type of a Stack.
What methods does it need to have to behave like this?&lt;/p&gt;

&lt;p&gt;Adding an element is referred to as &lt;code&gt;push&lt;/code&gt;ing.
Removing an element (and returning it) is referred to &lt;code&gt;pop&lt;/code&gt;ping.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top&lt;/code&gt; or &lt;code&gt;peek&lt;/code&gt; gives you the last value without removing?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isEmpty()&lt;/code&gt;
&lt;code&gt;size()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lots of problems using just &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reversing the order&lt;/li&gt;
&lt;li&gt;Detecting palindromes: a word that&amp;rsquo;s the same backwards and forwards

&lt;ul&gt;
&lt;li&gt;If you have an even number, the first half is the second half reversed&lt;/li&gt;
&lt;li&gt;If odd, ignore middle character,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; off the second half and compare to each of the first&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is related to the Homework.  Something similar.
Need to implement a Stack.
Any List will work.&lt;/p&gt;

&lt;p&gt;If singly linked list, push/pop from front, all O(1), otherwise if you do from
end, it&amp;rsquo;s O(N).
With doubly linked list, it&amp;rsquo;s O(1) from either end.&lt;/p&gt;

&lt;p&gt;LinkedList has push / pop methods in java.util.  Basically just reimplement this
along with the other functions above.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Queues.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Similar to Stacks, but FIFO, first in, first out.&lt;/li&gt;
&lt;li&gt;Adding from one end, Removing from the other.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 6: Linked Lists</title>
      <link>http://www.getup8.com/classes/data-structures/lecture6/</link>
      <pubDate>Mon, 26 Sep 2016 22:49:10 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture6/</guid>
      <description>

&lt;p&gt;ArrayList
Issues if we add to end if we&amp;rsquo;re out of room or if we try to add in the beginning (or middle). O(N).&lt;/p&gt;

&lt;h2 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h2&gt;

&lt;p&gt;A few types of linked lists: singly and doubly linked.&lt;/p&gt;

&lt;p&gt;Singly linked list:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each piece of data we insert is placed in a &lt;code&gt;Node&lt;/code&gt; object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node&lt;/code&gt; class defines two instance variables

&lt;ol&gt;
&lt;li&gt;The data&lt;/li&gt;
&lt;li&gt;Object reference to another node: &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t have prescribed locations in memory where each element is. You have
to start at the beginning and work your way to it using the &lt;code&gt;next&lt;/code&gt;
references.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; reference in last element of the list just points to &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linked list class has a &lt;code&gt;head&lt;/code&gt; reference to the first element of the list.  So
to get the third element, you have to keep a counter and start at the first and
go to the third using &lt;code&gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What if we want to access the nth element?  What&amp;rsquo;s Big-Oh cost?  &lt;em&gt;O(N)&lt;/em&gt;.
What about for an array? &lt;em&gt;O(const)&lt;/em&gt; or &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Linked lists suck!  At least for &lt;em&gt;get&lt;/em&gt; operations.  They&amp;rsquo;re more expensive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Node&amp;lt;AnyType&amp;gt; {
    AnyType data;
    Node&amp;lt;AnyType&amp;gt; next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class LinkedList&amp;lt;AnyType&amp;gt; {
    Node&amp;lt;AnyType&amp;gt; head;
    int size;

    // Getter
    AnyType get(int i) {
        // Initially point to beginning of list
        Node&amp;lt;AnyType&amp;gt; t = head;
        int count = 0;
        if (i &amp;gt;= size) {
            // throw exception..
        }
        while(count &amp;lt; i) {
            count++;
            // You&#39;ll get a null pointer exception here if `i` is greater than
            // the number of nodes in the list
            t = t.next;
        }
        return t.data;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what would the cost be to insert a new value at the beginning of the list?
Order 1. &lt;em&gt;O(1)&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a new node&lt;/li&gt;
&lt;li&gt;Put data into it&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;next&lt;/code&gt; equal to &lt;code&gt;head&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Make &lt;code&gt;head&lt;/code&gt; refer to it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What about if you want to insert at the end?  You need to iterate all the way
to the end since you only have a reference to &lt;code&gt;head&lt;/code&gt;.  So it&amp;rsquo;s O(N).&lt;/p&gt;

&lt;p&gt;What about the middle?  O(N) still.  But once I have the reference to the node
I want to insert after already, it&amp;rsquo;s easy and O(1).  Remember that.  So if
you&amp;rsquo;re already moving across the list, and you decide you want to insert
something, it&amp;rsquo;s easy and cheap.&lt;/p&gt;

&lt;p&gt;Another benefit: We don&amp;rsquo;t need to specify how large this list is going to be.&lt;/p&gt;

&lt;p&gt;This is a building block for other data structures.&lt;/p&gt;

&lt;h2 id=&#34;doubly-linked-lists&#34;&gt;Doubly Linked Lists&lt;/h2&gt;

&lt;p&gt;You have a head and a tail.  You add a &lt;code&gt;previous&lt;/code&gt; pointer.  So you can move in
both directions, forwards or backwards.&lt;/p&gt;

&lt;p&gt;Iterator interface.  ListIterator interface adds an extra bit that allows you
to move forward or backward; it exploits the doubly linked list.&lt;/p&gt;

&lt;p&gt;Uses &amp;ldquo;sentinal nodes&amp;rdquo;.  The head data has no data.  The first piece of data is
actually at head.next().  The tail also doesn&amp;rsquo;t have any data.  The last node
is tail.previous().&lt;/p&gt;

&lt;p&gt;Nodes now have three fields:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;previous&lt;/li&gt;
&lt;li&gt;next&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An empty doubly linked list:
null -&amp;gt; head -&amp;gt; tail -&amp;gt; null&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re going to insert data, we&amp;rsquo;d insert after head or before tail.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a node, populated with data&lt;/li&gt;
&lt;li&gt;&lt;code&gt;previous&lt;/code&gt; points to &lt;code&gt;head&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; points to &lt;code&gt;head.next&lt;/code&gt; (instead of &lt;code&gt;tail&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head.next.previous&lt;/code&gt; (or &lt;code&gt;tail.previous&lt;/code&gt;) points to it&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head.next&lt;/code&gt; points to it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can actually implement both types with sentinal nodes (singly and doubly).&lt;/p&gt;

&lt;p&gt;Next class:
ArrayList code.
Doubly LinkedList code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lecture 5: Iterators and Interfaces</title>
      <link>http://www.getup8.com/classes/data-structures/lecture5/</link>
      <pubDate>Wed, 21 Sep 2016 22:49:15 -0400</pubDate>
      
      <guid>http://www.getup8.com/classes/data-structures/lecture5/</guid>
      <description>&lt;p&gt;A list is a type of collection.&lt;/p&gt;

&lt;p&gt;A collection is&lt;/p&gt;

&lt;p&gt;Iterator is another class that attaches to a particular Collection used to go
through the Collection, item by item.&lt;/p&gt;

&lt;p&gt;Can have multiple iterators attached to a collection moving at different
speeds, different locations.&lt;/p&gt;

&lt;p&gt;java.util.Iterator is an &amp;ldquo;interface&amp;rdquo; provides methods.&lt;/p&gt;

&lt;p&gt;Iterator method is a factory method and its job is to construct a class. It&amp;rsquo;s
job is to create some Iterator object that iterates across the collection and
returns something.&lt;/p&gt;

&lt;p&gt;An iterator is its own object of type Iterator.&lt;/p&gt;

&lt;p&gt;This is all in chapter 3 of the book..&lt;/p&gt;

&lt;p&gt;Iterators have 3 methods:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Boolean: hasNext (if true, move on to next, if false, end of list)&lt;/li&gt;
&lt;li&gt;AnyType next(): returns current element (telling where we aer),
 advances to next&lt;/li&gt;
&lt;li&gt;void remove(): remove the item? or the iterator? think the latter.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;while hasNext() == True:
  next()&lt;/p&gt;

&lt;p&gt;List interface extends Collection.  So all methods included in List.&lt;/p&gt;

&lt;p&gt;So the List interface adds additional methods to take advantage of ordered
space.&lt;/p&gt;

&lt;p&gt;ListIterator is same as Iterator but can move forward/backward since lists have
an order (Collections do not)&lt;/p&gt;

&lt;p&gt;Some mumbo jumbo about generics and objects and using int vs Integer???&lt;/p&gt;

&lt;p&gt;Advanced for loop expects an iterable / iterator. (a.iterator())
It creates an iterator and uses it to go through.
Understand how to make something work in an advanced for loop.&lt;/p&gt;

&lt;p&gt;Iterator is generic so defaults to object.  Need to cast it like
java.util.Iterator&lt;Integer&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;When we create an ArrayList, we need to preallocate the size (let&amp;rsquo;s say 10
elements) and keep track of the first empty location.  So on instantiation,
it&amp;rsquo;s location zero.  We don&amp;rsquo;t know how long it&amp;rsquo;s going to be.&lt;/p&gt;

&lt;p&gt;Adding elements at end of list is O(1) operation until you fill up the list
(the preallocated size) and then it&amp;rsquo;s O(n) to copy it to the new array.&lt;/p&gt;

&lt;p&gt;So how big do we make it when we need a larger list?  Wasteful to just make it
11 since it&amp;rsquo;s quite possible to make it 12 later.&lt;/p&gt;

&lt;p&gt;Randomly, they multiply by 1.5.  Or 2.&lt;/p&gt;

&lt;p&gt;Removing elements also O(1). So is changing a specific element.&lt;/p&gt;

&lt;p&gt;What if you want to insert an element in the middle or beginning?  You have to
copy everything and move it over.  So O(n).  n is how many things you&amp;rsquo;re
moving?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;On Canvas there is a download of all the code in the textbook.&lt;/p&gt;

&lt;p&gt;Difference between extends and implements?
implements Iterator..&lt;/p&gt;

&lt;p&gt;theSize is how many items are filled up.
Length of theItems is how long the arraylist is.&lt;/p&gt;

&lt;p&gt;ensureCapacity().&lt;/p&gt;

&lt;p&gt;When creating the array, you construct an array of objects and then cast it to
generics.  The compiler doesn&amp;rsquo;t know how to create an array of generics.&lt;/p&gt;

&lt;p&gt;&amp;ndash;&lt;/p&gt;

&lt;p&gt;By starting at the end with add() you don&amp;rsquo;t have to move anything (or iterate
through anything) if you&amp;rsquo;re adding to the end.&lt;/p&gt;

&lt;p&gt;ArrayListIterator() is not provided by java, need to implement ourselves.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>